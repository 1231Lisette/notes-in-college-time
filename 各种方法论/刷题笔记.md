# 刷题笔记

## 前言

我这个训练强度估计是学一点忘一下啊，主要是你不刷题啊，你不写啊，跟你数学一样你不写题你怎么记住Σ(°ロ°)

## 双指针技巧秒杀7道链表题目

> 2025.8.12

### 1. 合并两个有序链表

leetcode21情况描述：我是先看了题解后再自己敲一遍的，原理什么的我懂了（应该吧），然后自己敲之后没通过测试用例，我又不知道怎么去纠正，有点懵懵的

```Python
# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, val=0, next=None):
#         self.val = val
#         self.next = next
class Solution:
    def mergeTwoLists(self, list1: Optional[ListNode], list2: Optional[ListNode]) -> Optional[ListNode]:
        p1 = list1 #指向第一个链表的头
        p2 = list2 # 指向第二个链表的头
        p = ListNode(-1) # 创建一个新链表，来存放合并后的链表
        dummy = p

        while p1 and p2 is not None:
            if p1.val < p2.val:
                dummy.next = p1
                p1 = p1.next
            else:
                dummy.next = p2
                p2 = p2.next
            if p1 is not None:
                dummy.next = p1 
                p1 = p1.next
            
        return p
    	# 输入list1 = [1,2,4]；list2 = [1,3,4]
        # 输出[-1,4]   
        # 预计输出[1,1,2,3,4,4]

```

现在重新看一下labuladong的思路

```Python
class Solution:
    def mergeTwoLists(self, list1, list2) -> ListNode
    # 虚拟头结点
    dummy = ListNode(-1)
    p = dummy 
    p1 = list1
    p2 = list2
    
    while p1 is not None and p2 is not None:
        # 比较p1和p2两个指针，将值较小的节点接到p指针
        if p1.val > p2.val:
            p.next = p2
            p2 = p2.next
        else:
            p.next = p1
            p1 = p1.next
            
        # p 指针不断前进
        p = p.next
        
    if p1 is not None:
        p.next = p1

    if p2 is not None:
        p.next = p2 #这里相比我的后面没有移动list1/2的指针
            
     return dummy.next
```

----

### 单链表的分解

leetcode86 感觉如果每一道题每一道题后面自己再敲一遍我的效率还是太慢了，我现在主要是先学一些逻辑和思路

一定要有一个

- dummy变量来存放一个链表的头节点
- 一个移动的p指针来进行其他操作（一般是遍历）

---

这道题的思想是

- 先将一个链表分解成两个链表
- 但是原链表的p指针不能直接前进（p=p.next❌）
- 而是用要断开原链表中的每个节点的next指针，用temp先临时存放p.next，后面再赋值回去；这里的意图就是然原链表的那个节点到新链表后面，如果直接让p指针前进就没断来原链表啦！结果链表中会包含一个环

- 最后再连接两个链表嗯

总的来说，如果我们需要把原链表的节点接到新链表上，而不是 new 新节点来组成新链表的话，那么断开节点和原链表之间的链接可能是必要的。那其实我们可以养成一个好习惯，但凡遇到这种情况，就**把原链表的节点断开**，这样就不会出错了。

```Python
class Solution:
    def partition(self, head: ListNode, x: int) -> ListNode:
        # 存放小于 x 的链表的虚拟头结点
        dummy1 = ListNode(-1)
        # 存放大于等于 x 的链表的虚拟头结点
        dummy2 = ListNode(-1)
        # p1, p2 指针负责生成结果链表
        p1, p2 = dummy1, dummy2
        # p 负责遍历原链表，类似合并两个有序链表的逻辑
        # 这里是将一个链表分解成两个链表
        p = head
        while p:
            if p.val >= x:
                p2.next = p
                p2 = p2.next
            else:
                p1.next = p
                p1 = p1.next
            # 不能直接让 p 指针前进，
            # p = p.next
            # 断开原链表中的每个节点的 next 指针
            temp = p.next
            p.next = None
            p = temp
        # 连接两个链表
        p1.next = dummy2.next

        return dummy1.next
```

---



### 2. 合并K个升序链表（自己不太会）

leetcode 23

还没看题解前的思路：链表数组中有k个升序链表，给每个链表一个头指针、移动指针；再创一个空链表头和总指针

dummy1,2,3

p1,2,3

dummy，p

然后像前面逻辑一样进行升序排列

但是有k个的话，我怎么创建变量

```python 
k = list[i].length
# 有循环创建变量怎么一说吗
# 看了题解后发现我这个想法是行不通的，谁很明显的单线思想，你学那些数据结构不会用的吗哈哈哈哈哈
```

ai给出来的代码(我的思路的)

```python
class ListNode:
    def __init__(self, val=0, next=None):
        self.val = val
        self.next = next

class Solution:
    def mergeKLists(self, lists):
        # 初始化一个列表，存储每个链表的当前指针
        pointers = lists[:]  # 直接使用传入的列表，但注意可能包含None
        dummy = ListNode(-1)
        p = dummy
        
        while True:
            min_val = float('inf')
            min_index = -1
            # 遍历所有指针，找到最小节点
            for i, node in enumerate(pointers):
                if node is not None and node.val < min_val:
                    min_val = node.val
                    min_index = i
            
            # 如果没有找到有效节点，说明所有链表都处理完了
            if min_index == -1:
                break
                
            # 将最小节点接到结果链表
            p.next = pointers[min_index]
            p = p.next
            # 移动该链表的指针
            pointers[min_index] = pointers[min_index].next
        
        return dummy.next
```

最开始写就是穷举的笨版本，后面优化才是这样嗯

大佬的思路

- 这道题的逻辑类似合并两个有序链表，难点在于，如何快速得到k个节点中最小的节点，接到结果链表上
- 然后就想到这里要用到**优先级队列**这种数据结构，把**链表的节点放入一个最小堆**，就可以每次获得**k个节点中的最小节点**

好的这时候我就不懂了，那这个二叉堆（二叉树，这俩是一样的吗）就得我自己建立一个二叉堆（初始化和定义），然后再把这个链表数组的头节点放进去（增），然后二叉堆的头节点就会是k个链表中最小的值然后再把这个头节点接到总链表去（改）以此类推，但是我懵逼了。

```PYthon
import heapq

class ListNode:
    def __init__(self, val=0, next=None):
        self.val = val
        self.next = next

    # 重载比较运算符，方便将 ListNode 加入最小堆
    # 因为下面使用了元组，所以就可以不会用到这个，这个是防止两个节点的元素的值相同时，Python会尝试比较其他属性如（next），然后就会导致错误
    # 元组的比较是基于第一个元素（node.val）进行的；如果第一个元素相同，会比较第二个元素（索引i）；索引i是整数，可以安全比较；只有在极少数情况下，当val和i都相同时，才会比较第三个元素（节点对象）
    def __lt__(self, other):
        return self.val < other.val

class Solution:
    def mergeKLists(self, lists):
        if not lists:
            return None
        # 虚拟头结点
        dummy = ListNode(-1)
        p = dummy
        # 优先级队列，最小堆
        pq = []
        # 将 k 个链表的头结点加入最小堆
        for i, head in enumerate(lists):
            if head is not None:
                heapq.heappush(pq, (head.val, i, head))

        while pq:
            # 获取最小节点，接到结果链表中
            val, i, node = heapq.heappop(pq)
            p.next = node
            if node.next is not None:
                heapq.heappush(pq, (node.next.val, i, node.next))
            # p 指针不断前进
            p = p.next
            
        return dummy.next
```

我服了刚刚新华社发了一篇夜读——《夜读 | 一个能破解任何复杂问题的顶级思维[新华社](javascript:void(0);)*2025年08月22日 21:12* *北京*》，然后接到的思维是：**分而治之**。。。然后我就顺势ds了一下，这是然后刚好是递归的分治法



1. **分割阶段**：将K个链表列表分成两个较小的子列表
2. **递归解决**：对每个子列表递归地应用相同的合并过程
3. **合并阶段**：将两个已合并的链表合并成一个完整的链表
4. **基本情况**：当链表列表为空或只有一个链表时，直接返回

算法流程

```
mergeKLists(lists):
  如果lists为空: 返回None
  如果lists只有一个链表: 返回这个链表
  
  将lists分成两半: left和right
  递归合并left部分: left_merged = mergeKLists(left)
  递归合并right部分: right_merged = mergeKLists(right)
  合并left_merged和right_merged: result = mergeTwoLists(left_merged, right_merged)
  返回result
```

```python
class ListNode:
    def __init__(self, val=0, next=None):
        self.val = val
        self.next = next

class Solution:
    def mergeKLists(self, lists):
        # 基本情况处理
        if not lists:
            return None
        if len(lists) == 1:
            return lists[0]
        
        # 分治：将链表列表分成两半
        mid = len(lists) // 2
        left = self.mergeKLists(lists[:mid])  # 递归合并左半部分
        right = self.mergeKLists(lists[mid:]) # 递归合并右半部分
        
        # 合并两个已排序的链表
        return self.mergeTwoLists(left, right)
    
    def mergeTwoLists(self, l1, l2):
        # 合并两个有序链表的辅助函数
        dummy = ListNode(0)
        current = dummy
        
        while l1 and l2:
            if l1.val < l2.val:
                current.next = l1
                l1 = l1.next
            else:
                current.next = l2
                l2 = l2.next
            current = current.next
        
        # 将剩余部分连接到结果链表
        current.next = l1 if l1 else l2
        
        return dummy.next
```

ok现在瓦达西是看不懂的呵呵

---



### 3. 单链表的倒数第k个节点

从前往后数第k个节点很简单，一个for就好了；但从后往前数第k个节点呢？

我：假设链表有 `n` 个节点，倒数第 `k` 个节点就是正数第 `n - k + 1` 个节点，不也是一个 for 循环的事儿吗？

牛人：是的，但是算法题一般只给你一个 `ListNode` 头结点代表一条单链表，你不能直接得出这条链表的长度 `n`，而需要先遍历一遍链表算出 `n` 的值，然后再遍历链表计算第 `n - k + 1` 个节点。也就是说，这个解法需要遍历两次链表才能得到出倒数第 `k` 个节点。

我：那么，我们能不能**只遍历一次链表**，就算出倒数第 `k` 个节点？

牛人：可以做到的，如果是面试问到这道题，面试官肯定也是希望你给出只需遍历一次链表的解法。

首先，我们先让一个指针 `p1` 指向链表的头节点 `head`，然后走 `k` 步：

![img](https://labuladong.online/algo/images/linked-list-two-pointer/1.jpeg)

现在的 `p1`，只要再走 `n - k` 步，就能走到链表末尾的空指针了对吧？

趁这个时候，再用一个指针 `p2` 指向链表头节点 `head`：

![](https://labuladong.online/algo/images/linked-list-two-pointer/2.jpeg)

接下来就很显然了，让 `p1` 和 `p2` 同时向前走，`p1` 走到链表末尾的空指针时前进了 `n - k` 步，`p2` 也从 `head` 开始前进了 `n - k` 步，停留在第 `n - k + 1` 个节点上，即恰好停链表的倒数第 `k` 个节点上：

![img](https://labuladong.online/algo/images/linked-list-two-pointer/3.jpeg)

这样，只遍历了一次链表，就获得了倒数第 `k` 个节点 `p2`。

代码逻辑

```python
# 返回链表的倒数第 k 个节点
def findFromEnd(head: ListNode, k: int) -> ListNode:
    p1 = head
    # p1 先走 k 步
    for i in range(k):
        p1 = p1.next
    p2 = head
    # p1 和 p2 同时走 n - k 步
    while p1 != None:
        p2 = p2.next
        p1 = p1.next
    # p2 现在指向第 n - k + 1 个节点，即倒数第 k 个节点
    return p2
```

**力扣题目**：给你一个链表，删除链表的倒数第 `n` 个结点，并且返回链表的头结点。

```python
# 主函数
class Solution:
    def removeNthFromEnd(self, head: ListNode, n: int) -> ListNode:
        # 虚拟头结点
        dummy = ListNode(-1)
        dummy.next = head
        # 删除倒数第 n 个，要先找倒数第 n + 1 个节点
        x = self.findFromEnd(dummy, n + 1)
        # 删掉倒数第 n 个节点
        x.next = x.next.next
        return dummy.next
        
    def findFromEnd(self, head: ListNode, k: int) -> ListNode:
        # 代码见上文
        pass
```

不过注意我们又使用了虚拟头结点的技巧，也是为了防止出现空指针的情况，比如说链表总共有 5 个节点，题目就让你删除倒数第 5 个节点，也就是第一个节点，那按照算法逻辑，应该首先找到倒数第 6 个节点。但第一个节点前面已经没有节点了，这就会出错。

但有了我们虚拟节点 `dummy` 的存在，就避免了这个问题，能够对这种情况进行正确的删除。

---

### 4. 链表的中点

问题的关键也在于我们无法直接得到单链表的长度 `n`，常规方法也是先遍历链表计算 `n`，再遍历一次得到第 `n / 2` 个节点，也就是中间节点。

如果想一次遍历就得到中间节点，也需要耍点小聪明，使用**「快慢指针」**的技巧：

- 我们让两个指针 `slow` 和 `fast` 分别指向链表头结点 `head`。
- **每当慢指针 `slow` 前进一步，快指针 `fast` 就前进两步，这样，当 `fast` 走到链表末尾时，`slow` 就指向了链表中点**。

```python
class Solution:
    # 快慢指针初始化指向 head
    def middleNode(self, head: ListNode) -> ListNode:
        slow = head
        fast = head
        # 快指针走到末尾时停止
        while fast is not None and fast.next is not None:
            # 慢指针走一步，快指针走两步
            slow = slow.next
            fast = fast.next.next
        # 慢指针指向中点
        return slow
```

需要注意的是，如果链表长度为偶数，也就是说中点有两个的时候，我们这个解法返回的节点是靠后的那个节点。

---

### 5. 判断链表是否包含环

解决方案也是用快慢指针：

- 每当慢指针 `slow` 前进一步，快指针 `fast` 就前进两步。
- 如果 `fast` 最终能正常走到链表末尾，说明链表中没有环；
- 如果 `fast` 走着走着竟然和 `slow` 相遇了，那肯定是 `fast` 在链表中转圈了，说明链表中含有环。

只需要把寻找链表中点的代码稍加修改就行了：

```python
class Solution:
    # 快慢指针初始化指向 head
    def hasCycle(self, head: ListNode) -> bool:
        slow = head
        fast = head
        # 快指针走到末尾时停止
        while fast is not None and fast.next is not None:
            # 慢指针走一步，快指针走两步
            slow = slow.next
            fast = fast.next.next
            # 快慢指针相遇，说明含有环
            if slow == fast:
                return True
        # 不包含环
        return False
```

---

这个问题还有进阶版，也是力扣第 142 题「[环形链表 II](https://leetcode.cn/problems/linked-list-cycle-ii/)」：如果链表中含有环，如何计算这个环的起点？

举个例子，环的起点是指下面这幅图中的节点 2：

![img](https://labuladong.online/algo/images/linked-list-two-pointer/circularlinkedlist.png)

这里先直接看一下寻找环起点的解法代码：

```python
class Solution:
    def detectCycle(self, head: ListNode):
        fast, slow = head, head
        while fast and fast.next:
            fast = fast.next.next
            slow = slow.next
            if fast == slow:
                break
        
        # 上面的代码类似 hasCycle 函数
        if not fast or not fast.next:
            # fast 遇到空指针说明没有环
            return None
        
        # 重新指向头结点
        slow = head 
        # 快慢指针同步前进，相交点就是环起点
        while slow != fast:
            fast = fast.next
            slow = slow.next
        return slow
```

可以看到，当快慢指针相遇时，让其中任一个指针指向头节点，然后让它俩以相同速度前进，再次相遇时所在的节点位置就是环开始的位置。为什么要这样呢？这里简单说一下其中的原理。

我们假设快慢指针相遇时，慢指针 `slow` 走了 `k` 步，那么快指针 `fast` 一定走了 `2k` 步：

![img](https://labuladong.online/algo/images/linked-two-pointer/3.jpeg)

`fast` 一定比 `slow` 多走了 `k` 步，这多走的 `k` 步其实就是 `fast` 指针在环里转圈圈，所以 `k` 的值就是环长度的「整数倍」。

假设相遇点距环的起点的距离为 `m`，那么结合上图的 `slow` 指针，环的起点距头结点 `head` 的距离为 `k - m`，也就是说如果从 `head` 前进 `k - m` 步就能到达环起点。

巧的是，如果从相遇点继续前进 `k - m` 步，也恰好到达环起点。因为结合上图的 `fast` 指针，从相遇点开始走k步可以转回到相遇点，那走 `k - m` 步肯定就走到环起点了：

![img](https://labuladong.online/algo/images/linked-two-pointer/2.jpeg)

所以，只要我们把快慢指针中的任一个重新指向 `head`，然后两个指针同速前进，`k - m` 步后一定会相遇，相遇之处就是环的起点了。

这里瓦达西问了皂角幼师deepseek也没太明白，我要完蛋了，跳过吧

---



### 6. 两个链表是否相交

```pyhon
class Solution:
    def getIntersectionNode(self, headA: ListNode, headB: ListNode) -> ListNode:
        lenA, lenB = 0, 0
        # 计算两条链表的长度
        p1, p2 = headA, headB
        while p1:
            lenA += 1
            p1 = p1.next
        while p2:
            lenB += 1
            p2 = p2.next
        
        # 让 p1 和 p2 到达尾部的距离相同
        p1, p2 = headA, headB
        if lenA > lenB:
            for _ in range(lenA - lenB):
                p1 = p1.next
        else:
            for _ in range(lenB - lenA):
                p2 = p2.next
        
        # 看两个指针是否会相同，p1 == p2 时有两种情况：
        # 1、要么是两条链表不相交，他俩同时走到尾部空指针
        # 2、要么是两条链表相交，他俩走到两条链表的相交点
        while p1 != p2:
            p1 = p1.next
            p2 = p2.next
        
        return p1
```

天才！！！！！！！！！！！！！！！

---



### 双指针技巧秒杀链表题目总结（ai）

#### 一、核心思想

双指针技巧的本质是**用空间换时间**，通过维护两个（或多个）指针在链表上移动，**一次遍历**就能解决原本需要多次遍历的问题。

##### 为什么链表需要双指针？

- 链表只能从头开始遍历，不能随机访问
- 很多问题如果用常规方法需要遍历多次
- 双指针可以在一次遍历中同时获取多个位置的信息

#### 二、双指针的三种基本模式

##### 1.  快慢指针（速度不同）

**特点**：两个指针移动速度不同

- `slow` 每次走1步
- `fast` 每次走2步

**适用场景**：

- 找链表中点
- 判断链表是否有环
- 找倒数第k个节点

**核心原理**：利用速度差来定位特殊位置

##### 2. 前后指针（间距固定）

**特点**：两个指针保持固定间距

- 先让一个指针走k步
- 然后两个指针同时移动

**适用场景**：

- 找倒数第k个节点
- 删除倒数第n个节点

**核心原理**：利用固定间距来定位相对位置

##### 3. 分离指针（分别处理）

**特点**：两个指针分别遍历不同的链表或部分

- 各自独立移动
- 最终可能相遇或比较

**适用场景**：

- 合并两个有序链表
- 判断两个链表是否相交
- 链表分解

#### 三、解题万能框架

##### 第一步：确定问题类型

看到链表题，先判断：

- 需要找特殊位置？ → 考虑快慢指针或前后指针
- 需要合并/分解？ → 考虑分离指针
- 需要比较两个链表？ → 考虑分离指针

##### 第二步：套用模板

###### 模板1：快慢指针

```python
def solve(head):
    slow = fast = head
    while fast and fast.next:
        slow = slow.next      # 慢指针走1步
        fast = fast.next.next # 快指针走2步
    # 此时slow指向特殊位置
    return slow
```

###### 模板2：前后指针

```python
def solve(head, k):
    p1 = head
    # p1先走k步
    for i in range(k):
        p1 = p1.next
    
    p2 = head
    # 两个指针同时移动
    while p1:
        p1 = p1.next
        p2 = p2.next
    # 此时p2指向倒数第k个节点
    return p2
```

###### 模板3：合并/分解

```python
def solve(list1, list2):
    dummy = ListNode(-1)  # 虚拟头节点
    p = dummy
    p1, p2 = list1, list2
    
    while p1 and p2:
        if condition:
            p.next = p1
            p1 = p1.next
        else:
            p.next = p2
            p2 = p2.next
        p = p.next
    
    # 处理剩余部分
    p.next = p1 if p1 else p2
    return dummy.next
```

#### 第三步：必备技巧

##### 虚拟头节点（dummy）

**作用**：简化边界情况处理，特别是头节点可能被删除时

```python
dummy = ListNode(-1)
dummy.next = head
# 最后返回 dummy.next
```

##### 断开原链表连接

**场景**：当需要把原链表节点移动到新链表时

```python
temp = p.next  # 保存下一个节点
p.next = None  # 断开当前节点
p = temp       # 继续遍历
```

#### 四、正确的做题思路

##### 1. 理解题目本质

- 不要被题目表面描述迷惑
- 找出题目的核心操作：查找、删除、合并、分解

##### 2. 画图分析

- 在纸上画出链表结构
- 模拟指针移动过程
- 理解每一步操作的目的

##### 3. 分步实现

1. **初始化**：创建必要的指针和虚拟节点
2. **主循环**：实现核心逻辑
3. **收尾**：处理剩余部分和边界情况

##### 4. 常见陷阱

- 忘记移动指针导致死循环
- 没有处理空链表的情况
- 指针越界（访问null.next）
- 没有正确断开原链表连接

#### 五、具体题型速查

| 题目类型      | 使用技巧 | 关键点               |
| ------------- | -------- | -------------------- |
| 找链表中点    | 快慢指针 | fast走2步，slow走1步 |
| 判断环形链表  | 快慢指针 | 相遇则有环           |
| 找环的起点    | 快慢指针 | 相遇后重置一个指针   |
| 删除倒数第n个 | 前后指针 | 先让一个指针走n步    |
| 合并有序链表  | 分离指针 | 比较大小，选择较小的 |
| 链表分解      | 分离指针 | 按条件分到不同链表   |
| 两链表相交    | 分离指针 | 对齐长度后同时移动   |

#### 六、练习建议

1. **先理解原理**：不要急着背代码，理解为什么这样做
2. **多画图**：复杂的题目一定要画图辅助理解
3. **注意细节**：边界条件、指针移动、内存管理
4. **举一反三**：掌握一种模式后，寻找相似题目练习

记住：**双指针不是万能的，但在链表题中是最优雅的解法**！

---



## 链表双指针经典习题

### **82删除排序链表中的重复元素 II** | [力扣](https://leetcode.cn/problems/remove-duplicates-from-sorted-list-ii/) | [LeetCode](https://leetcode.com/problems/remove-duplicates-from-sorted-list-ii/) | 🟠

放到哈希集合里面？[1,2,3,4,5],放进去的时候做标记，然后就进行删除，返回删除后的链表

哈希集合的代码我忘记了

那其实还不如直接遍历，然后取值，重复的节点就删除，yes（不行，得用哈希取值）

| 特性             | 哈希表 (Hash Table)          | 哈希集合 (Hash Set) |
| :--------------- | :--------------------------- | :------------------ |
| **存储内容**     | **键值对** (Key-Value Pairs) | 只有**键** (Keys)   |
| ****             | **`{key: value}`**           | **`{key}`**         |
| **要回答的问题** | “键X对应的**值**是什么？”    | “键X**存在**吗？”   |
| **Python实现**   | `dict` (字典)                | `set` (集合)        |
| **比喻**         | 带索引卡的抽屉柜             | 签到表              |

```python
def deleteDuplicates(head):
    """
    使用哈希表删除排序链表中的重复元素 II
    :type head: ListNode
    :rtype: ListNode
    """
    # 边界条件：空链表直接返回
    if not head:
        return head

    # 第一步：遍历链表，统计每个值出现的次数
    # count_map 就是我们的“小本本”
    count_map = {}
    current = head
    while current:
        # get(current.val, 0) 意思是：
        # 如果 current.val 这个数字在本子上还没记过，就默认次数是 0
        # 然后 +1，就是它实际出现的次数
        count_map[current.val] = count_map.get(current.val, 0) + 1
        current = current.next # 移动到下一个节点

    # 第二步：再次遍历链表，删除重复节点
    # 创建一个虚拟头节点，简化对真实头节点的删除操作
    dummy = ListNode(0)
    dummy.next = head
    # prev 指向当前节点的前一个节点
    prev = dummy
    # current 指向当前正在检查的节点
    current = head

    while current:
        # 查看“小本本”，看看当前节点的值重复了几次
        if count_map[current.val] > 1:
            # 次数大于1，说明是重复的，需要删除
            # 把前一个节点(prev)的 next 指针，直接指向当前节点的下一个节点(current.next)
            # 这样，current 节点就被从链表中“摘除”了
            prev.next = current.next
            # 注意：此时 prev 不需要移动，因为它还是“新”的当前节点的前一个节点
        else:
            # 次数等于1，说明是唯一的，需要保留
            # 那么 prev 就可以移动到当前节点的位置了
            prev = current
        # 无论当前节点是否被删除，我们都需要继续检查下一个节点
        current = current.next

    # dummy.next 指向的就是处理后的新链表的头节点
    return dummy.next
```

```python
def deleteDuplicates(head):
    """
    使用哈希集删除排序链表中的重复元素 II
    :type head: ListNode
    :rtype: ListNode
    """
    if not head:
        return head

    # --- 第一步：找出所有需要删除的重复值 ---
    print("--- 第一步：确定要删除的值 ---")
    seen_once = set()  # 存放只见过一次的值
    to_remove = set()  # 存放需要删除的值（即重复的值）
    current = head
    while current:
        print(f"  检查节点值: {current.val}")
        if current.val in seen_once:
            # 如果之前见过一次，现在又见到了，说明是重复的
            print(f"    -> 之前见过 {current.val}，现在再次出现，标记为需删除")
            seen_once.discard(current.val)  # 从见过一次的集合中移除
            to_remove.add(current.val)       # 添加到需要删除的集合中
        elif current.val not in to_remove:
            # 如果既没在见过一次的集合里，也没在要删除的集合里
            # 说明是第一次见到
            print(f"    -> 第一次见到 {current.val}，暂存")
            seen_once.add(current.val)
        # else: 如果 current.val 已经在 to_remove 里了，
        # 说明它已经被标记为重复了，无需操作
        current = current.next

    print(f"  最终需要删除的值 (集合 to_remove): {sorted(to_remove) if to_remove else '无'}")
    print("-" * 25)

    # --- 第二步：删除包含重复值的节点 ---
    print("--- 第二步：删除节点 ---")
    # 使用虚拟头节点简化操作，特别是处理头节点被删除的情况
    dummy = ListNode(0)
    dummy.next = head
    prev = dummy
    current = head

    while current:
        print(f"  检查节点值: {current.val}")
        if current.val in to_remove:
            print(f"    -> 值 {current.val} 在删除列表中，执行删除")
            # 删除当前节点：将前一个节点(prev)的next指针，
            # 指向当前节点的下一个节点(current.next)
            prev.next = current.next
            # 注意：删除节点后，prev 不移动，因为它还是新current的前一个节点
        else:
            print(f"    -> 值 {current.val} 不在删除列表中，保留节点")
            # 保留当前节点，prev 移动到当前节点
            prev = current
        # 无论是否删除，current 都要向前移动
        current = current.next

    print("-" * 25)
    # 返回新链表的头节点
    return dummy.next
```



牛人：这道题可以有多种解法，最简单粗暴的解法是用 [哈希集合](https://labuladong.online/algo/data-structure-basic/hash-set/) 来记录重复节点，需要额外的空间复杂度，我们不讨论。下面探讨如何用双指针技巧，避免使用额外的空间复杂度来求解。

- 第一种思路，也是我比较推荐的方式，就是把这种题转化成 [链表的双指针技巧汇总](https://labuladong.online/algo/essential-technique/linked-list-skills-summary/) 中讲的链表分解的技巧。题目其实就是让你**把链表分解成「重复元素」和「不重复元素」两条链表，然后把不重复元素这条链表返回即可。**
- 第二种思路，可以把这道题理解为 [链表的双指针技巧汇总](https://labuladong.online/algo/essential-technique/linked-list-skills-summary/) 中讲的 [83. 删除排序链表中的重复元素](https://leetcode.cn/problems/remove-duplicates-from-sorted-list) 的变体，只不过 83 题让你把多于的重复元素去掉，这道题要求你把所有重复的元素全都去掉。

- 第三种思路，可以用递归思维来做，稍微难理解一些，我也写出来供大家参考。

```python
# 推荐的通用解法，运用链表分解的技巧
class Solution:
    def deleteDuplicates(self, head: ListNode) -> ListNode:
        # 将原链表分解为两条链表
        # 一条链表存放不重复的节点，另一条链表存放重复的节点
        # 运用虚拟头结点技巧，题目说了 node.val <= 100，所以用 101 作为虚拟头结点
        dummyUniq = ListNode(101)
        dummyDup = ListNode(101)

        pUniq, pDup = dummyUniq, dummyDup
        p = head

        while p is not None:
            if (p.next is not None and p.val == p.next.val) or p.val == pDup.val:
                # 发现重复节点，接到重复链表后面
                pDup.next = p
                pDup = pDup.next
            else:
                # 不是重复节点，接到不重复链表后面
                pUniq.next = p
                pUniq = pUniq.next

            p = p.next
            # 将原链表和新链表断开
            pUniq.next = None
            pDup.next = None

        return dummyUniq.next

# 快慢双指针解法
class Solution2:
    def deleteDuplicates(self, head: ListNode) -> ListNode:
        dummy = ListNode(-1)
        p, q = dummy, head
        while q is not None:
            if q.next is not None and q.val == q.next.val:
                # 发现重复节点，跳过这些重复节点
                while q.next is not None and q.val == q.next.val:
                    q = q.next
                q = q.next
                # 此时 q 跳过了这一段重复元素
                if q is None:
                    p.next = None
                # 不过下一段元素也可能重复，等下一轮 while 循环判断
            else:
                # 不是重复节点，接到 dummy 后面
                p.next = q
                p = p.next
                q = q.next
        return dummy.next

# 递归解法
class Solution3:
    # 定义：输入一条单链表头结点，返回去重之后的单链表头结点
    def deleteDuplicates(self, head: ListNode) -> ListNode:
        # base case
        if head is None or head.next is None:
            return head
        if head.val != head.next.val:
            # 如果头结点和身后节点的值不同，则对之后的链表去重即可
            head.next = self.deleteDuplicates(head.next)
            return head
        # 如果如果头结点和身后节点的值相同，则说明从 head 开始存在若干重复节点
        # 越过重复节点，找到 head 之后那个不重复的节点
        while head.next is not None and head.val == head.next.val:
            head = head.next
        # 直接返回那个不重复节点开头的链表的去重结果，就把重复节点删掉了
        return self.deleteDuplicates(head.next)
```

---

### 378.有序矩阵中第k小的元素

给你一个 `n x n` 矩阵 `matrix` ，其中每行和每列元素均按升序排序，找到矩阵中第 `k` 小的元素。
请注意，它是 **排序后** 的第 `k` 小元素，而不是第 `k` 个 **不同** 的元素。

你必须找到一个内存复杂度优于 `O(n2)` 的解决方案。

**示例 1：**

```
输入：matrix = [[1,5,9],[10,11,13],[12,13,15]], k = 8
输出：13
解释：矩阵中的元素为 [1,5,9,10,11,12,13,13,15]，第 8 小元素是 13
```

**示例 2：**

```
输入：matrix = [[-5]], k = 1
输出：-5
```

**提示：**

- `n == matrix.length`
- `n == matrix[i].length`
- `1 <= n <= 300`
- `-109 <= matrix[i][j] <= 109`
- 题目数据 **保证** `matrix` 中的所有行和列都按 **非递减顺序** 排列
- `1 <= k <= n2`

---

我的思路：先把这n条链表合并，但是我一直不是很会处理矩阵啊；

又用优先队列啊，我没辙了。

好聪明啊

在矩阵中找第k小元素”就等价于**“合并 n 个有序链表，并找到合并后第 k 个元素”**。

让我们来模拟一下，如果我们手动合并，会怎么做：

1. **初始状态**：我们有 `n` 个列表的开头，也就是每行的第一个元素。
2. **第一步**：在这 `n` 个开头的元素中，找到最小的那个。把它拿出来，作为我们最终合并后列表的第一个元素。
3. **第二步**：我们刚刚从哪个列表（哪一行）拿走了元素，现在就看那个列表的下一个元素。
4. **重复**：现在我们又有 `n` 个“候选”元素了（其中一个是刚才新补充的），继续在这些候选者中找最小的，拿出来，再补充......
5. 一直重复这个过程，直到所有列表的元素都被取完，我们就得到了一个完整的、合并后的有序列表。

它做了一个聪明的优化：既然我只需要**第 `k` 个**元素，那我**没有必要**把所有元素都合并完。我只需要执行 `k` 次“取最小、再补充”的操作，第 `k` 次取出的那个数，就是我要的答案。这样当 `k` 远小于矩阵总元素数量时，可以节省大量计算。

```python
from queue import PriorityQueue

class Solution:
    def kthSmallest(self, matrix: List[List[int]], k: int) -> int:
        # 存储二元组 (matrix[i][j], i, j)
        # i, j 记录当前元素的索引位置，用于生成下一个节点
        pq = PriorityQueue()

        # 初始化优先级队列，把每一行的第一个元素装进去
        for i in range(len(matrix)):
            pq.put((matrix[i][0], i, 0))

        res = -1
        # 执行合并多个有序链表的逻辑，找到第 k 小的元素
        while not pq.empty() and k > 0:
            cur = pq.get()
            # 按照元素大小升序排序
            res = cur[0]
            k -= 1
            # 链表中的下一个节点加入优先级队列
            i, j = cur[1], cur[2]
            if j + 1 < len(matrix[i]):
                pq.put((matrix[i][j + 1], i, j + 1))
        return res
```

