```c
	  //printf("USART 发送测试：Hello！\r\n");  // \r\n 是换行符（串口助手显示更清晰）
	  //HAL_Delay(10000);  // 延时10秒
	  //static uint16_t test_value = 0;  // 测试数值（从0开始递增）
    
    // 使用你的 fputc 函数发送数据（本质是调用你写的函数）
	  //printf("show_msg.n0.val=%d\xff\xff\xff", test_value);  // 串口屏显示指令
	  //test_value++;  // 数值递增（根据串口屏支持范围调整）
	  //HAL_Delay(1000);  // 延时1秒
	/*Car_Forward();
	for(int d = 0; d < 1000; d++)
	{
		Motor_SetPWM(d,d);
		HAL_Delay(50);
		if(d==999)
		{
			Car_Stop();
			break;
		}
	}
	while(1);*/
```

```python
#!/usr/bin/env python3
# -*- coding: utf-8 -*-

import serial
import time
import threading

class STM32Communication:
    def __init__(self, port='/dev/ttyUSB0', baudrate=9600):
        """
        初始化STM32通信
        port: 串口设备路径，根据实际情况修改 (/dev/ttyUSB0, /dev/ttyAMA0等)
        baudrate: 波特率，必须与STM32端一致
        """
        try:
            self.serial_port = serial.Serial(
                port=port,
                baudrate=baudrate,
                bytesize=serial.EIGHTBITS,
                parity=serial.PARITY_NONE,
                stopbits=serial.STOPBITS_ONE,
                timeout=1
            )
            print(f"成功连接到STM32: {port}, 波特率: {baudrate}")
            
            # 启动接收线程
            self.running = True
            self.receive_thread = threading.Thread(target=self.receive_data)
            self.receive_thread.daemon = True
            self.receive_thread.start()
            
        except Exception as e:
            print(f"串口连接失败: {e}")
            self.serial_port = None
    
    def send_data(self, data):
        """发送数据到STM32"""
        if self.serial_port and self.serial_port.is_open:
            try:
                # 确保数据以\r\n结尾
                if not data.endswith('\r\n'):
                    data += '\r\n'
                
                self.serial_port.write(data.encode('utf-8'))
                print(f"发送到STM32: {data.strip()}")
                return True
            except Exception as e:
                print(f"发送数据失败: {e}")
                return False
        return False
    
    def receive_data(self):
        """接收STM32发来的数据 (在独立线程中运行)"""
        buffer = ""
        while self.running and self.serial_port and self.serial_port.is_open:
            try:
                if self.serial_port.in_waiting > 0:
                    data = self.serial_port.read(self.serial_port.in_waiting).decode('utf-8', errors='ignore')
                    buffer += data
                    
                    # 处理完整的行
                    while '\n' in buffer:
                        line, buffer = buffer.split('\n', 1)
                        line = line.strip()
                        if line:
                            print(f"从STM32接收: {line}")
                            self.process_received_data(line)
                
                time.sleep(0.01)  # 避免CPU占用过高
            except Exception as e:
                print(f"接收数据错误: {e}")
                time.sleep(0.1)
    
    def process_received_data(self, data):
        """处理接收到的数据"""
        if "STM32_HEARTBEAT" in data:
            print("收到STM32心跳信号")
        elif "STM32_STATUS" in data:
            print("收到STM32状态信息")
        elif "STM32_ACK" in data:
            print("收到STM32确认信息")
        else:
            print(f"收到其他数据: {data}")
    
    def send_test_coordinate(self, x, y, z):
        """发送测试坐标数据"""
        coord_data = f"COORD:{x:.3f},{y:.3f},{z:.3f}"
        self.send_data(coord_data)
    
    def send_test_velocity(self, vx, vy, vz):
        """发送测试速度数据"""
        vel_data = f"VEL:{vx:.3f},{vy:.3f},{vz:.3f}"
        self.send_data(vel_data)
    
    def send_test_command(self, cmd):
        """发送测试命令"""
        cmd_data = f"CMD:{cmd}"
        self.send_data(cmd_data)
    
    def close(self):
        """关闭连接"""
        self.running = False
        if self.serial_port and self.serial_port.is_open:
            self.serial_port.close()
            print("串口连接已关闭")

def main():
    print("=== STM32与树莓派通信测试程序 ===")
    print("请确保:")
    print("1. STM32已正确连接并运行")
    print("2. 串口线连接正确")
    print("3. 修改下面的串口设备路径")
    print()
    
    # 根据实际情况修改串口设备路径
    # 常见路径: /dev/ttyUSB0, /dev/ttyAMA0, /dev/ttyS0
    SERIAL_PORT = '/dev/ttyUSB0'  # 请根据实际情况修改！
    BAUDRATE = 9600
    
    # 创建通信对象
    stm32_comm = STM32Communication(SERIAL_PORT, BAUDRATE)
    
    if stm32_comm.serial_port is None:
        print("无法建立通信连接，程序退出")
        return
    
    try:
        print("通信建立成功！开始测试...")
        print("按 Ctrl+C 退出程序")
        print("-" * 50)
        
        test_counter = 0
        
        while True:
            print(f"\n=== 测试循环 {test_counter + 1} ===")
            
            # 测试1: 发送简单消息
            stm32_comm.send_data(f"Hello STM32! 测试消息 #{test_counter}")
            time.sleep(2)
            
            # 测试2: 发送模拟坐标数据
            x = test_counter * 0.1
            y = test_counter * 0.2
            z = 0.0
            stm32_comm.send_test_coordinate(x, y, z)
            time.sleep(2)
            
            # 测试3: 发送模拟速度数据
            vx = 0.5
            vy = 0.3
            vz = 0.0
            stm32_comm.send_test_velocity(vx, vy, vz)
            time.sleep(2)
            
            # 测试4: 发送控制命令
            commands = ["START", "STOP", "FORWARD", "BACKWARD", "LEFT", "RIGHT"]
            cmd = commands[test_counter % len(commands)]
            stm32_comm.send_test_command(cmd)
            time.sleep(3)
            
            test_counter += 1
            
            # 防止无限循环，测试10次后询问
            if test_counter % 10 == 0:
                user_input = input("\n继续测试？(y/n): ")
                if user_input.lower() != 'y':
                    break
                    
    except KeyboardInterrupt:
        print("\n用户中断程序")
    except Exception as e:
        print(f"程序运行错误: {e}")
    finally:
        stm32_comm.close()
        print("测试程序结束")

if __name__ == "__main__":
    main()
```

