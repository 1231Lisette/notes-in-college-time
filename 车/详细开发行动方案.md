# 详细开发行动方案

基于对需求和现有代码的分析，以下是针对三个核心需求点的详细开发行动方案。

## 1. 树莓派与STM32的通信实现方案

### 1.1 通信协议设计

设计一个简单高效的通信协议，包含以下要素：
```
帧格式：
[帧头(1字节)] [命令类型(1字节)] [数据长度(1字节)] [数据(N字节)] [校验和(1字节)] [帧尾(1字节)]

帧头：固定为 0xAA
命令类型：
  - 0x01：坐标数据
  - 0x02：运动命令
  - 0x03：状态查询
  - 0x04：状态回复
数据长度：数据字段的字节数
数据：根据命令类型不同而不同
校验和：从命令类型到数据的所有字节的和取低8位
帧尾：固定为 0xFF
```

### 1.2 STM32端实现步骤

1. **修改USART3接收中断处理函数**：
```c
// 在main.c中添加以下全局变量
#define MAX_BUFFER_SIZE 128
uint8_t uart3_rx_buffer[MAX_BUFFER_SIZE];
uint16_t uart3_rx_index = 0;
uint8_t uart3_frame_received = 0;

// 修改HAL_UART_RxCpltCallback函数中USART3的处理部分
if (huart == &huart3) {
    // 将接收到的字节存入缓冲区
    uart3_rx_buffer[uart3_rx_index++] = aRxBuffer;
    
    // 检查帧头
    if (uart3_rx_index == 1 && uart3_rx_buffer[0] != 0xAA) {
        uart3_rx_index = 0;
    }
    
    // 检查是否接收到完整帧
    if (uart3_rx_index > 3) { // 至少包含帧头、命令、长度
        uint8_t data_length = uart3_rx_buffer[2];
        if (uart3_rx_index >= data_length + 5) { // 帧头(1)+命令(1)+长度(1)+数据(N)+校验(1)+帧尾(1)
            // 检查帧尾
            if (uart3_rx_buffer[uart3_rx_index-1] == 0xFF) {
                // 计算校验和
                uint8_t checksum = 0;
                for (int i = 1; i < uart3_rx_index-2; i++) {
                    checksum += uart3_rx_buffer[i];
                }
                
                // 验证校验和
                if (checksum == uart3_rx_buffer[uart3_rx_index-2]) {
                    uart3_frame_received = 1; // 标记接收到完整帧
                }
            }
            
            // 无论校验是否通过，都重置接收索引准备接收下一帧
            uart3_rx_index = 0;
        }
    }
    
    // 防止缓冲区溢出
    if (uart3_rx_index >= MAX_BUFFER_SIZE) {
        uart3_rx_index = 0;
    }
    
    // 继续接收下一个字节
    HAL_UART_Receive_IT(&huart3, (uint8_t *)&aRxBuffer, 1);
}
```

2. **添加数据解析和处理函数**：
```c
// 在main.c中添加
void ProcessReceivedFrame(void) {
    if (uart3_frame_received) {
        uint8_t cmd_type = uart3_rx_buffer[1];
        uint8_t data_len = uart3_rx_buffer[2];
        
        switch (cmd_type) {
            case 0x01: // 坐标数据
                // 解析坐标数据
                float x, y, z;
                memcpy(&x, &uart3_rx_buffer[3], 4);
                memcpy(&y, &uart3_rx_buffer[7], 4);
                memcpy(&z, &uart3_rx_buffer[11], 4);
                
                // 更新显示
                UpdateCoordinateDisplay(x, y, z);
                break;
                
            case 0x02: // 运动命令
                // 解析运动命令
                float target_x, target_y, pwm_value;
                memcpy(&target_x, &uart3_rx_buffer[3], 4);
                memcpy(&target_y, &uart3_rx_buffer[7], 4);
                memcpy(&pwm_value, &uart3_rx_buffer[11], 4);
                
                // 执行运动命令
                ExecuteMovementCommand(target_x, target_y, (uint16_t)pwm_value);
                break;
                
            case 0x03: // 状态查询
                // 发送当前状态
                SendStatusResponse();
                break;
                
            default:
                break;
        }
        
        uart3_frame_received = 0; // 重置标志
    }
}
```

3. **添加发送函数**：
```c
// 在usart.c中添加
void USART3_SendFrame(uint8_t cmd_type, uint8_t *data, uint8_t data_len) {
    uint8_t tx_buffer[MAX_BUFFER_SIZE];
    uint8_t checksum = 0;
    uint16_t index = 0;
    
    // 帧头
    tx_buffer[index++] = 0xAA;
    
    // 命令类型
    tx_buffer[index++] = cmd_type;
    checksum += cmd_type;
    
    // 数据长度
    tx_buffer[index++] = data_len;
    checksum += data_len;
    
    // 数据
    for (int i = 0; i < data_len; i++) {
        tx_buffer[index++] = data[i];
        checksum += data[i];
    }
    
    // 校验和
    tx_buffer[index++] = checksum;
    
    // 帧尾
    tx_buffer[index++] = 0xFF;
    
    // 发送数据
    HAL_UART_Transmit(&huart3, tx_buffer, index, HAL_MAX_DELAY);
}
```

4. **在主循环中添加处理逻辑**：
```c
// 修改main.c中的while(1)循环
while (1) {
    // 处理接收到的数据帧
    ProcessReceivedFrame();
    
    // 其他任务...
    
    HAL_Delay(10); // 短暂延时，避免CPU占用过高
}
```

### 1.3 树莓派端实现步骤

1. **创建串口通信Python脚本**：
```python
#!/usr/bin/env python3
import serial
import struct
import time
import rospy
from nav_msgs.msg import Odometry

# 配置串口
ser = serial.Serial(
    port='/dev/ttyAMA0',  # 树莓派UART端口，可能需要根据实际情况调整
    baudrate=9600,
    parity=serial.PARITY_NONE,
    stopbits=serial.STOPBITS_ONE,
    bytesize=serial.EIGHTBITS,
    timeout=1
)

# 全局变量存储当前坐标
current_x = 0.0
current_y = 0.0
current_z = 0.0

# 回调函数，处理接收到的里程计数据
def odom_callback(data):
    global current_x, current_y, current_z
    current_x = data.pose.pose.position.x
    current_y = data.pose.pose.position.y
    current_z = data.pose.pose.position.z
    
    # 发送坐标数据到STM32
    send_coordinate_data(current_x, current_y, current_z)

# 发送坐标数据函数
def send_coordinate_data(x, y, z):
    # 帧头
    frame = bytearray([0xAA])
    
    # 命令类型：坐标数据
    cmd_type = 0x01
    frame.append(cmd_type)
    
    # 数据长度：3个float，每个4字节，共12字节
    data_len = 12
    frame.append(data_len)
    
    # 数据：x, y, z坐标（float类型，各4字节）
    frame.extend(struct.pack('<f', x))
    frame.extend(struct.pack('<f', y))
    frame.extend(struct.pack('<f', z))
    
    # 计算校验和
    checksum = 0
    for i in range(1, len(frame)):
        checksum += frame[i]
    checksum &= 0xFF  # 取低8位
    frame.append(checksum)
    
    # 帧尾
    frame.append(0xFF)
    
    # 发送数据
    ser.write(frame)

# 发送运动命令函数
def send_movement_command(target_x, target_y, pwm_value):
    # 帧头
    frame = bytearray([0xAA])
    
    # 命令类型：运动命令
    cmd_type = 0x02
    frame.append(cmd_type)
    
    # 数据长度：2个float坐标和1个uint16占空比，共10字节
    data_len = 10
    frame.append(data_len)
    
    # 数据：目标x, y坐标和PWM占空比
    frame.extend(struct.pack('<f', target_x))
    frame.extend(struct.pack('<f', target_y))
    frame.extend(struct.pack('<H', pwm_value))
    
    # 计算校验和
    checksum = 0
    for i in range(1, len(frame)):
        checksum += frame[i]
    checksum &= 0xFF  # 取低8位
    frame.append(checksum)
    
    # 帧尾
    frame.append(0xFF)
    
    # 发送数据
    ser.write(frame)

# 接收并处理STM32发送的数据
def receive_data():
    if ser.in_waiting > 0:
        # 寻找帧头
        while ser.in_waiting > 0:
            byte = ser.read(1)
            if byte[0] == 0xAA:
                break
        
        # 如果找到帧头且有足够的数据
        if ser.in_waiting >= 2:
            cmd_type = ser.read(1)[0]
            data_len = ser.read(1)[0]
            
            # 确保有足够的数据可读
            if ser.in_waiting >= data_len + 2:  # +2是校验和和帧尾
                data = ser.read(data_len)
                checksum = ser.read(1)[0]
                frame_end = ser.read(1)[0]
                
                # 验证帧尾和校验和
                if frame_end == 0xFF:
                    # 计算校验和
                    calc_checksum = cmd_type + data_len
                    for byte in data:
                        calc_checksum += byte
                    calc_checksum &= 0xFF
                    
                    if calc_checksum == checksum:
                        # 处理不同类型的命令
                        if cmd_type == 0x04:  # 状态回复
                            process_status_response(data)

# 主函数
def main():
    # 初始化ROS节点
    rospy.init_node('stm32_communication_node', anonymous=True)
    
    # 订阅里程计话题
    rospy.Subscriber('/camera/odom/sample', Odometry, odom_callback)
    
    # 主循环
    rate = rospy.Rate(10)  # 10Hz
    while not rospy.is_shutdown():
        # 接收并处理来自STM32的数据
        receive_data()
        
        # 保持循环频率
        rate.sleep()

if __name__ == '__main__':
    try:
        main()
    except rospy.ROSInterruptException:
        pass
    finally:
        ser.close()
```

2. **创建启动脚本**：
```bash
#!/bin/bash
# 启动ROS节点和通信脚本
source /opt/ros/noetic/setup.bash
source ~/catkin_ws/devel/setup.bash

# 启动T265相机节点
roslaunch realsense2_camera rs_t265.launch &

# 等待相机节点启动
sleep 5

# 启动通信节点
python3 ~/stm32_communication.py
```

## 2. T265坐标数据传输与显示方案

### 2.1 陶晶驰串口屏界面设计

使用陶晶驰串口屏设计软件创建以下界面元素：

1. **坐标显示区域**：
   - 三个数字显示组件，分别显示X、Y、Z坐标
   - 组件ID：`n0`(X坐标)、`n1`(Y坐标)、`n2`(Z坐标)
   - 添加适当的标签和单位

2. **轨迹显示区域**：
   - 使用曲线图组件显示小车运动轨迹
   - 组件ID：`s0`
   - X轴表示X坐标，Y轴表示Y坐标

3. **状态显示区域**：
   - 文本显示组件，显示当前状态和命令
   - 组件ID：`t0`

4. **控制按钮区域**（可选）：
   - 添加手动控制按钮
   - 组件ID：`b0`(前进)、`b1`(后退)、`b2`(左转)、`b3`(右转)、`b4`(停止)

### 2.2 STM32端显示实现

1. **添加坐标显示更新函数**：
```c
// 在Hmi.c中添加
void UpdateCoordinateDisplay(float x, float y, float z) {
    // 更新X坐标显示
    printf("n0.val=%d\xff\xff\xff", (int)(x * 100)); // 放大100倍以显示小数
    
    // 更新Y坐标显示
    printf("n1.val=%d\xff\xff\xff", (int)(y * 100));
    
    // 更新Z坐标显示
    printf("n2.val=%d\xff\xff\xff", (int)(z * 100));
    
    // 刷新显示
    printf("ref_star\xff\xff\xff");
}
```

2. **添加轨迹显示更新函数**：
```c
// 在Hmi.c中添加
#define MAX_POINTS 50 // 轨迹点数量上限

// 轨迹点数组
float trajectory_x[MAX_POINTS];
float trajectory_y[MAX_POINTS];
uint8_t trajectory_count = 0;

void UpdateTrajectoryDisplay(float x, float y) {
    // 添加新的轨迹点
    if (trajectory_count < MAX_POINTS) {
        trajectory_x[trajectory_count] = x;
        trajectory_y[trajectory_count] = y;
        trajectory_count++;
    } else {
        // 数组已满，移除最早的点
        for (int i = 0; i < MAX_POINTS - 1; i++) {
            trajectory_x[i] = trajectory_x[i + 1];
            trajectory_y[i] = trajectory_y[i + 1];
        }
        trajectory_x[MAX_POINTS - 1] = x;
        trajectory_y[MAX_POINTS - 1] = y;
    }
    
    // 清除曲线图
    printf("cle s0\xff\xff\xff");
    
    // 添加所有轨迹点
    for (int i = 0; i < trajectory_count; i++) {
        printf("add s0,%d,%d\xff\xff\xff", 
               (int)(trajectory_x[i] * 100), 
               (int)(trajectory_y[i] * 100));
    }
}
```

3. **添加状态显示更新函数**：
```c
// 在Hmi.c中添加
void UpdateStatusDisplay(const char* status) {
    printf("t0.txt=\"%s\"\xff\xff\xff", status);
}
```

4. **在主循环中定期更新显示**：
```c
// 在main.c的while(1)循环中添加
// 定义更新间隔
#define DISPLAY_UPDATE_INTERVAL 200 // 200ms
uint32_t last_display_update = 0;

// 在主循环中
if (HAL_GetTick() - last_display_update >= DISPLAY_UPDATE_INTERVAL) {
    // 如果有新的坐标数据，更新显示
    if (new_coordinate_data) {
        UpdateCoordinateDisplay(current_x, current_y, current_z);
        UpdateTrajectoryDisplay(current_x, current_y);
        new_coordinate_data = 0;
    }
    
    last_display_update = HAL_GetTick();
}
```

### 2.3 防止数据丢包机制

1. **添加数据包序号**：
```c
// 修改通信协议，在命令类型后添加序号字段
// [帧头(1字节)] [命令类型(1字节)] [序号(1字节)] [数据长度(1字节)] [数据(N字节)] [校验和(1字节)] [帧尾(1字节)]

// 在树莓派端发送函数中添加序号管理
packet_seq = 0

def send_coordinate_data(x, y, z):
    global packet_seq
    # 帧头
    frame = bytearray([0xAA])
    
    # 命令类型：坐标数据
    cmd_type = 0x01
    frame.append(cmd_type)
    
    # 序号
    frame.append(packet_seq)
    packet_seq = (packet_seq + 1) % 256
    
    # 数据长度
    data_len = 12
    frame.append(data_len)
    
    # 数据
    frame.extend(struct.pack('<f', x))
    frame.extend(struct.pack('<f', y))
    frame.extend(struct.pack('<f', z))
    
    # 计算校验和
    checksum = 0
    for i in range(1, len(frame)):
        checksum += frame[i]
    checksum &= 0xFF
    frame.append(checksum)
    
    # 帧尾
    frame.append(0xFF)
    
    # 发送数据
    ser.write(frame)
```

2. **在STM32端添加序号检查**：
```c
// 在main.c中添加
uint8_t last_received_seq = 0xFF; // 初始值设为无效值

// 在ProcessReceivedFrame函数中添加序号检查
uint8_t seq = uart3_rx_buffer[2]; // 假设序号在第3个字节
uint8_t cmd_type = uart3_rx_buffer[1];

// 检查是否有丢包（序号不连续）
if ((last_received_seq + 1) % 256 != seq) {
    // 丢包处理，可以请求重发或记录日志
    char log_msg[50];
    sprintf(log_msg, "Packet loss detected: %d -> %d", last_received_seq, seq);
    UpdateStatusDisplay(log_msg);
}

last_received_seq = seq;
```

## 3. 小车运动控制与PID算法实现

### 3.1 PID控制器实现

1. **添加PID控制器结构和初始化函数**：
```c
// 在motor.c中添加
typedef struct {
    float Kp;           // 比例系数
    float Ki;           // 积分系数
    float Kd;           // 微分系数
    float target;       // 目标值
    float error;        // 当前误差
    float last_error;   // 上次误差
    float error_sum;    // 误差累积
    float output;       // 输出值
    float output_max;   // 输出上限
    float output_min;   // 输出下限
} PID_Controller;

// 初始化PID控制器
void PID_Init(PID_Controller *pid, float Kp, float Ki, float Kd, float output_min, float output_max) {
    pid->Kp = Kp;
    pid->Ki = Ki;
    pid->Kd = Kd;
    pid->target = 0;
    pid->error = 0;
    pid->last_error = 0;
    pid->error_sum = 0;
    pid->output = 0;
    pid->output_max = output_max;
    pid->output_min = output_min;
}

// 设置PID目标值
void PID_SetTarget(PID_Controller *pid, float target) {
    pid->target = target;
    // 重置误差累积，避免积分饱和
    pid->error_sum = 0;
}

// 计算PID输出
float PID_Compute(PID_Controller *pid, float current_value) {
    // 计算当前误差
    pid->error = pid->target - current_value;
    
    // 计算误差累积（积分项）
    pid->error_sum += pid->error;
    
    // 计算PID输出
    pid->output = pid->Kp * pid->error + 
                  pid->Ki * pid->error_sum + 
                  pid->Kd * (pid->error - pid->last_error);
    
    // 限制输出范围
    if (pid->output > pid->output_max) {
        pid->output = pid->output_max;
    } else if (pid->output < pid->output_min) {
        pid->output = pid->output_min;
    }
    
    // 保存当前误差为上次误差
    pid->last_error = pid->error;
    
    return pid->output;
}
```

2. **创建直线运动控制函数**：
```c
// 在motor.c中添加
// 全局PID控制器
PID_Controller pid_straight;
PID_Controller pid_rotation;

// 当前位置和目标位置
float current_x = 0, current_y = 0, current_angle = 0;
float target_x = 0, target_y = 0;

// 初始化运动控制
void MotionControl_Init(void) {
    // 初始化直线PID控制器
    PID_Init(&pid_straight, 5.0f, 0.1f, 1.0f, -500, 500);
    
    // 初始化旋转PID控制器
    PID_Init(&pid_rotation, 10.0f, 0.0f, 2.0f, -500, 500);
    
    // 启动PWM
    StartPWM();
}

// 更新当前位置
void UpdateCurrentPosition(float x, float y, float angle) {
    current_x = x;
    current_y = y;
    current_angle = angle;
}

// 计算两点间距离
float CalculateDistance(float x1, float y1, float x2, float y2) {
    return sqrtf((x2-x1)*(x2-x1) + (y2-y1)*(y2-y1));
}

// 计算目标角度（弧度）
float CalculateTargetAngle(float x1, float y1, float x2, float y2) {
    return atan2f(y2-y1, x2-x1);
}

// 角度归一化到[-PI, PI]
float NormalizeAngle(float angle) {
    while (angle > M_PI) angle -= 2*M_PI;
    while (angle < -M_PI) angle += 2*M_PI;
    return angle;
}

// 执行直线运动
void MoveStraight(float distance, uint16_t base_pwm) {
    // 设置PID目标
    PID_SetTarget(&pid_straight, distance);
    
    // 设置电机方向
    Car_Forward();
    
    // 初始位置
    float start_x = current_x;
    float start_y = current_y;
    float traveled_distance = 0;
    
    while (1) {
        // 计算已行驶距离
        traveled_distance = CalculateDistance(start_x, start_y, current_x, current_y);
        
        // 如果已到达目标距离或接近目标，则停止
        if (traveled_distance >= distance || fabs(distance - traveled_distance) < 0.02) {
            Car_Stop();
            break;
        }
        
        // 计算PID输出
        float correction = PID_Compute(&pid_straight, traveled_distance);
        
        // 计算左右电机PWM
        uint16_t left_pwm = base_pwm + (int16_t)correction;
        uint16_t right_pwm = base_pwm - (int16_t)correction;
        
        // 限制PWM范围
        if (left_pwm > 999) left_pwm = 999;
        if (right_pwm > 999) right_pwm = 999;
        
        // 设置电机PWM
        Motor_SetPWM(left_pwm, right_pwm);
        
        // 短暂延时
        HAL_Delay(10);
    }
}

// 执行旋转运动
void Rotate(float target_angle, uint16_t base_pwm) {
    // 计算需要旋转的角度
    float angle_diff = NormalizeAngle(target_angle - current_angle);
    
    // 设置PID目标
    PID_SetTarget(&pid_rotation, target_angle);
    
    // 设置旋转方向
    if (angle_diff > 0) {
        Car_TurnRight();
    } else {
        Car_TurnLeft();
    }
    
    while (1) {
        // 计算当前角度与目标角度的差值
        angle_diff = NormalizeAngle(target_angle - current_angle);
        
        // 如果已接近目标角度，则停止
        if (fabs(angle_diff) < 0.05) {
            Car_Stop();
            break;
        }
        
        // 计算PID输出
        float correction = PID_Compute(&pid_rotation, current_angle);
        
        // 计算电机PWM
        uint16_t pwm = base_pwm + fabs((int16_t)correction);
        if (pwm > 999) pwm = 999;
        
        // 设置电机PWM
        if (angle_diff > 0) {
            Motor_SetPWM(pwm, 0);
        } else {
            Motor_SetPWM(0, pwm);
        }
        
        // 短暂延时
        HAL_Delay(10);
    }
}

// 执行运动命令
void ExecuteMovementCommand(float x, float y, uint16_t pwm) {
    // 保存目标位置
    target_x = x;
    target_y = y;
    
    // 计算目标角度
    float target_angle = CalculateTargetAngle(current_x, current_y, target_x, target_y);
    
    // 先旋转到目标方向
    Rotate(target_angle, pwm / 2);
    
    // 计算距离
    float distance = CalculateDistance(current_x, current_y, target_x, target_y);
    
    // 直线行驶到目标位置
    MoveStraight(distance, pwm);
    
    // 发送状态回复
    uint8_t status_data[1] = {0x01}; // 0x01表示完成
    USART3_SendFrame(0x04, status_data, 1);
    
    // 更新状态显示
    char status_msg[50];
    sprintf(status_msg, "Reached (%.2f, %.2f)", target_x, target_y);
    UpdateStatusDisplay(status_msg);
}
```

### 3.2 命令解析和执行流程

1. **添加命令解析函数**：
```c
// 在main.c中添加
void ParseMovementCommand(uint8_t *data, uint8_t data_len) {
    if (data_len < 10) return; // 数据长度不足
    
    // 解析目标坐标和PWM值
    float target_x, target_y;
    uint16_t pwm_value;
    
    memcpy(&target_x, &data[0], 4);
    memcpy(&target_y, &data[4], 4);
    memcpy(&pwm_value, &data[8], 2);
    
    // 执行运动命令
    ExecuteMovementCommand(target_x, target_y, pwm_value);
}
```

2. **修改主循环中的命令处理**：
```c
// 在ProcessReceivedFrame函数中修改case 0x02部分
case 0x02: // 运动命令
    // 解析运动命令
    ParseMovementCommand(&uart3_rx_buffer[3], uart3_rx_buffer[2]);
    break;
```

### 3.3 完整运动控制流程

1. **初始化**：
```c
// 在main.c的USER CODE BEGIN 2部分添加
// 初始化运动控制
MotionControl_Init();

// 设置初始位置
UpdateCurrentPosition(0.0f, 0.0f, 0.0f);

// 更新状态显示
UpdateStatusDisplay("Ready");
```

2. **主循环**：
```c
// 修改main.c的while(1)循环
while (1) {
    // 处理接收到的数据帧
    ProcessReceivedFrame();
    
    // 更新显示
    if (HAL_GetTick() - last_display_update >= DISPLAY_UPDATE_INTERVAL) {
        if (new_coordinate_data) {
            UpdateCoordinateDisplay(current_x, current_y, current_z);
            UpdateTrajectoryDisplay(current_x, current_y);
            
            // 更新运动控制中的当前位置
            UpdateCurrentPosition(current_x, current_y, current_angle);
            
            new_coordinate_data = 0;
        }
        
        last_display_update = HAL_GetTick();
    }
    
    // 短暂延时
    HAL_Delay(10);
}
```

## 4. 开发与测试步骤

### 4.1 开发顺序

1. **通信协议实现**：
   - 先实现STM32端的基本通信框架
   - 实现树莓派端的基本通信脚本
   - 测试基本的数据收发功能

2. **坐标数据传输与显示**：
   - 设计并上传陶晶驰串口屏界面
   - 实现STM32端的显示更新函数
   - 实现树莓派端的坐标数据发送功能
   - 测试坐标数据的传输和显示

3. **运动控制与PID算法**：
   - 实现PID控制器
   - 实现基本的直线和旋转运动函数
   - 实现命令解析和执行流程
   - 测试基本的运动控制功能

4. **系统集成与优化**：
   - 集成所有功能模块
   - 优化PID参数
   - 完善错误处理和异常情况
   - 进行全面测试

### 4.2 测试方法

1. **通信测试**：
   - 使用串口助手监控STM32和树莓派之间的通信
   - 验证数据包的正确发送和接收
   - 检查校验和和序号机制是否正常工作

2. **坐标显示测试**：
   - 使用固定的测试坐标数据
   - 验证陶晶驰屏幕上的坐标显示是否正确
   - 测试轨迹显示功能

3. **运动控制测试**：
   - 先测试简单的直线运动
   - 测试旋转运动
   - 测试复杂的路径规划
   - 验证PID控制的稳定性和精度

4. **系统集成测试**：
   - 测试完整的命令执行流程
   - 验证坐标反馈和状态更新
   - 测试异常情况处理

### 4.3 调试技巧

1. **使用串口打印调试信息**：
```c
// 在关键点添加调试信息
printf("Debug: PID output = %.2f\r\n", pid_output);
```

2. **使用LED指示状态**：
```c
// 使用板载LED指示不同状态
HAL_GPIO_TogglePin(GPIOC, GPIO_PIN_13); // 翻转LED状态
```

3. **分阶段测试**：
   - 先测试单个功能模块
   - 逐步集成多个模块
   - 最后测试完整系统

4. **参数调优**：
   - 从小的PID参数开始调整
   - 先调整Kp，再调整Kd，最后调整Ki
   - 记录不同参数下的系统响应
